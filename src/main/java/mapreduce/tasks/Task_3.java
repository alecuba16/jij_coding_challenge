package mapreduce.tasks;

import mapreduce.JobMapReduce;
import mapreduce.Utils;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.*;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.MultipleInputs;
import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

import java.io.*;
import java.util.*;

public class Task_3 extends JobMapReduce {
    public static final String TUPLE_SEPARATOR = "#";
    public static final String TABLE_ALIAS_SITES = "sites";
    public static final String TABLE_ALIAS_SITE_ADS = "siteAds";
    private static final int TUPLE_ALIAS_POS = 0;
    private static final int TUPLE_ADID_COUNT_POS = 1;
    private static final int TUPLE_IMPRESSIONS_POS = 2;
    private static final int TUPLE_SITENAME_POS = 3;

    /**
     * This function creates a string representation of a tuple of values. The tuple fields are separated by
     * the {@link Task_3#TUPLE_SEPARATOR} constant ({@link Task_3#TUPLE_SEPARATOR}) and each item position is
     * determined by the constants {@link Task_3#TABLE_ALIAS_SITES} and {@link Task_3#TABLE_ALIAS_SITE_ADS}.
     *
     * @param alias This param indicates the table alias or mapper origin of the tuple data, possible values are:
     * {@link Task_3#TABLE_ALIAS_SITES} and {@link Task_3#TABLE_ALIAS_SITE_ADS}.
     * @param adIdCount A string variable containing the count value of the adId.
     * @param impressions A string variable with the number of impressions of an ad.
     * @param siteName The site name.
     * @return The tuple encoded as string with the parameters separated with {@link Task_3#TUPLE_SEPARATOR} as separator.
     */
    public static String createValueTuple(String alias, String adIdCount, String impressions, String siteName) {
        ArrayList<String> outputTuple = new ArrayList<>();
        outputTuple.add(TUPLE_ALIAS_POS, alias);
        outputTuple.add(TUPLE_ADID_COUNT_POS, adIdCount);
        outputTuple.add(TUPLE_IMPRESSIONS_POS, impressions);
        outputTuple.add(TUPLE_SITENAME_POS, siteName);
        return String.join(TUPLE_SEPARATOR, outputTuple);
    }

    /**
     * This function is used to filter the tuples that are generated by the mapper that generates the siteAds data.
     * It expects the format generated by {@link Task_3#createValueTuple}.
     *
     * @param tuple A tuple of data in the format of {@link Task_3#createValueTuple}.
     * @return A boolean value with true if the tuple is generated by the siteAds mapper.
     */
    public static boolean isSiteAdsTuple(Text tuple) {
        String[] tupleFields = tuple.toString().split(TUPLE_SEPARATOR);
        return tupleFields[TUPLE_ALIAS_POS].equals(TABLE_ALIAS_SITE_ADS);
    }

    public static long getAdIdCount(Text tuple) {
        String[] tupleFields = tuple.toString().split(TUPLE_SEPARATOR);
        return Long.parseLong(tupleFields[TUPLE_ADID_COUNT_POS]);
    }

    /**
     * This function is used to get the number of Impressions of a given tuple generated by {@link Task_3#createValueTuple}.
     *
     * @param tuple A tuple of data in the format of {@link Task_3#createValueTuple}.
     * @return A long value indicating the number of impressions for a given ad.
     */
    public static long getImpressionCount(Text tuple) {
        String[] tupleFields = tuple.toString().split(TUPLE_SEPARATOR);
        return Long.parseLong(tupleFields[TUPLE_IMPRESSIONS_POS]);
    }

    /**
     * This function is used to get the siteName of a given tuple generated by {@link Task_3#createValueTuple}.
     *
     * @param tuple A tuple of data in the format of {@link Task_3#createValueTuple}.
     * @return A String value with the siteName.
     */
    public static String getSiteName(Text tuple) {
        String[] tupleFields = tuple.toString().split(TUPLE_SEPARATOR);
        return tupleFields[TUPLE_SITENAME_POS];
    }

    /**
     * This function is used to get the table alias for the current tuple generated by {@link Task_3#createValueTuple}.
     *
     * @param tuple A tuple of data in the format of {@link Task_3#createValueTuple}.
     * @return A String value with the alias ({@link Task_3#TABLE_ALIAS_SITES} or {@link Task_3#TABLE_ALIAS_SITE_ADS}).
     */
    public static String getTableAlias(Text tuple) {
        String[] tupleFields = tuple.toString().split(TUPLE_SEPARATOR);
        return tupleFields[TUPLE_ALIAS_POS];
    }

    public static class Task_3_Map_SiteAds extends Mapper<LongWritable, Text, Text, Text> {
        @Override
        public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
            // The First row key has the columns, so we skip the first row
            if (key.get() == 0) return;

            // Get the column names
            String siteIdColumn = context.getConfiguration().getStrings("siteIdColumn")[0];
            String impressionsColumn = context.getConfiguration().getStrings("impressionsColumn")[0];

            // Split the data
            String[] arrayValues = value.toString().split(",");

            // Check if array is completed
            if ((arrayValues.length<4)) return;

            // Get the values
            String siteIdValue = Utils.getAttributeSiteAds(arrayValues, siteIdColumn);
            String impressionsValue = Utils.getAttributeSiteAds(arrayValues, impressionsColumn);

            // Check if keyColumnValue is null, skip the row
            if (siteIdValue == null) return;
            // If there is no impressions, then the number of impressions is 0
            if (impressionsValue == null) impressionsValue = "0";

            // Create the output tuple with the adIdCount initialized to 1, this will be aggregated by the combiner
            String finalOutput = createValueTuple(TABLE_ALIAS_SITE_ADS, "1", impressionsValue, "");

            context.write(new Text(siteIdValue), new Text(finalOutput));
        }
    }

    public static class Task_3_Combiner extends Reducer<Text, Text, Text, Text> {
        @Override
        public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {
            // Counter variables
            long adidCount = 0;
            long impressionsSum = 0;
            String tableAlias = "";
            String siteName = "";
            for (Text tuple : values) {
                // Check if the current value type
                tableAlias = getTableAlias(tuple);
                if (isSiteAdsTuple(tuple)) {
                    // If it is a siteAds tuple, sum the AdId count and sum the number of impressions
                    adidCount += getAdIdCount(tuple);
                    impressionsSum += getImpressionCount(tuple);
                } else {
                    // If it is a sites tuple, set the siteName (only once)
                    siteName = getSiteName(tuple);
                }
            }
            // Prepare the output tuple with the format siteAds#adidCount#impressionsSum#siteName
            String finalOutput = createValueTuple(tableAlias, Long.toString(adidCount), Long.toString(impressionsSum), siteName);
            context.write(new Text(key), new Text(finalOutput));
        }
    }

    public static class Task_3_Map_Sites extends Mapper<LongWritable, Text, Text, Text> {
        @Override
        public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
            // First key has the columns, we have to find the positions of the columns we want to use
            if (key.get() == 0) return;

            // Get the column names
            String siteIdColumn = context.getConfiguration().getStrings("siteIdColumn")[0];
            String siteNameColumn = context.getConfiguration().getStrings("siteNameColumn")[0];

            // Split the data
            String[] arrayValues = value.toString().split(",");

            // Check if array is completed
            if ((arrayValues.length<2)) return;

            // Get the values
            String siteIdValue = Utils.getAttributesSites(arrayValues, siteIdColumn);
            String siteNameValue = Utils.getAttributesSites(arrayValues, siteNameColumn);

            // Check if siteIdColumnValue or siteNameColumnValue is null, if it is, skip the row
            if ((siteIdValue == null)||(siteNameValue ==null)) return;

            // Prepare the output tuple with the format sites#adIdCount#impressionsValue#siteNameColumnValue
            String finalOutput = createValueTuple(TABLE_ALIAS_SITES, "", "", siteNameValue);

            context.write(new Text(siteIdValue), new Text(finalOutput));
        }
    }

    public static class Task_3_Reduce extends Reducer<Text, Text, Text, Text> {
        @Override
        public void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {
            // Counter variables
            long adidCount = 0;
            long impressionsSum = 0;
            String siteName = "";

            for (Text tuple : values) {
                // Check if the current value type
                if (isSiteAdsTuple(tuple)) {
                    // If it is a siteAds tuple, sum the AdId count and sum the number of impressions
                    adidCount += getAdIdCount(tuple);
                    impressionsSum += getImpressionCount(tuple);
                } else {
                    // If it is a sites tuple, set the siteName (only once)
                    siteName = getSiteName(tuple);
                }
            }
            // Calculate the average number of impressions per adId
            Double avgImpressionsBySite = adidCount != 0 ? (double) impressionsSum / adidCount : null;
            // Output will be the adId,revenue with one decimal
            String finalOutput = String.format("%.1f", avgImpressionsBySite);

            context.write(new Text(siteName), new Text(finalOutput));
        }

        // Override the run method for adding the CSV column header
        @Override
        public void setup(Context context) throws IOException, InterruptedException {
            // Get the value if write header is enabled
            boolean writeHeader = context.getConfiguration().getBoolean("writeHeader", true);
            if (writeHeader) {
                Text column = new Text("siteName");
                Text values = new Text("averageImpressions");
                context.write(column, values);
            }
        }
    }

    public Task_3() {
        this.input = null;
        this.output = null;
    }

    @Override
    public boolean run() throws IOException, ClassNotFoundException, InterruptedException {
        Configuration configuration = new Configuration();
        // Define the new job and the name it will be given
        Job job = Job.getInstance(configuration, "TASK_3");
        Task_3.configureJob(job, this.input, this.output);
        return job.waitForCompletion(true);
    }


    public static void configureJob(Job job, String[] pathIn, String pathOut) throws IOException {
        job.setJarByClass(Task_3.class);

        String sitesPath = pathIn[0];
        String sitesAdsPath = pathIn[1];
        // Configurations
        job.getConfiguration().set("mapred.textoutputformat.separator", ",");
        job.getConfiguration().setStrings("siteIdColumn", "siteId");
        job.getConfiguration().setStrings("impressionsColumn", "impressions");
        job.getConfiguration().setStrings("siteNameColumn", "siteName");

        // Input mappers
        MultipleInputs.addInputPath(job, new Path(sitesPath), TextInputFormat.class, Task_3.Task_3_Map_Sites.class);
        MultipleInputs.addInputPath(job, new Path(sitesAdsPath), TextInputFormat.class, Task_3.Task_3_Map_SiteAds.class);

        // The mappers output classes
        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(Text.class);

        // Set the combiner, is the same as the reducer but without the avg
        job.setCombinerClass(Task_3_Combiner.class);

        // Set the reducer class it must use
        job.setReducerClass(Task_3.Task_3_Reduce.class);

        // The output will be Text
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(Text.class);

        // Cleanup output path
        Path outputPath = new Path(pathOut);
        FileSystem fs = FileSystem.get(outputPath.toUri(), job.getConfiguration());
        fs.delete(outputPath, true);

        // The files the job will read from/write to
        FileOutputFormat.setOutputPath(job, new Path(pathOut));
    }
}
